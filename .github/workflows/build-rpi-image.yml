name: Build Raspberry Pi Image

on:
  push:
    branches: [ main ]
    paths:
      - 'app.py'
      - 'requirements.txt'
      - 'Dockerfile'
      - 'build_rpi_image.py'
      - '.github/workflows/build-rpi-image.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'app.py'
      - 'requirements.txt'
      - 'Dockerfile'
      - 'build_rpi_image.py'
      - '.github/workflows/build-rpi-image.yml'
  workflow_dispatch:
    inputs:
      rpi_model:
        description: 'Raspberry Pi Model'
        required: true
        default: 'rpi4'
        type: choice
        options:
        - rpi3
        - rpi4
        - rpi5
      output_format:
        description: 'Output Format'
        required: true
        default: 'img'
        type: choice
        options:
        - img
        - iso
        - tar.gz

jobs:
  build-image:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Cache pi-gen dependencies
      uses: actions/cache@v4
      with:
        path: |
          pi-gen/cache
          pi-gen/work
          /var/cache/apt
        key: ${{ runner.os }}-pi-gen-${{ hashFiles('**/build-rpi-image.py') }}
        restore-keys: |
          ${{ runner.os }}-pi-gen-
          
    - name: Setup QEMU for ARM emulation
      run: |
        sudo apt-get update
        sudo apt-get install -y qemu-user-static binfmt-support
        
    - name: Install pi-gen dependencies
      run: |
        sudo apt-get install -y \
          coreutils quilt parted qemu-user-static debootstrap zerofree \
          zip dosfstools bsdtar libcap2-bin rsync xz-utils kpartx \
          git bc build-essential binutils-aarch64-linux-gnu \
          device-tree-compiler \
          ca-certificates curl gnupg \
          python3-dev python3-pip
        
    - name: Clone pi-gen
      run: |
        git clone --depth 1 --branch master https://github.com/RPi-Distro/pi-gen.git
        cd pi-gen
        git submodule update --init
        
    - name: Configure pi-gen for RPI Player
      run: |
        cd pi-gen
        
        # Create config file
        cat > config << EOF
        IMG_NAME=rpi-player
        TARGET_BOOT_SIZE=256
        APT_PROXY=
        ENABLE_SSH=1
        ENABLE_NONFREE=1
        ENABLE_MINIMAL=0
        ENABLE_HEADLESS=0
        ENABLE_XORG=1
        ENABLE_WM=1
        ENABLE_RPI_XORG=1
        ENABLE_SOUND=1
        ENABLE_DBUS=1
        ENABLE_PI_BPLUS=1
        ENABLE_PI_ZERO=1
        ENABLE_PI_ZERO_W=1
        ENABLE_PI2=1
        ENABLE_PI3=1
        ENABLE_PI4=1
        ENABLE_PI400=1
        ENABLE_CM4=1
        ENABLE_TOUCH=1
        ENABLE_I2C=1
        ENABLE_SPI=1
        ENABLE_CAMERA=1
        ENABLE_GPIO=1
        ENABLE_HWLIB=1
        ENABLE_64BIT=0
        ENABLE_PI3_DTOVERLAY=1
        EOF
        
    - name: Add RPI Player customization stages
      run: |
        cd pi-gen
        
        # Create stage for RPI Player
        mkdir -p stage-rpi-player
        
        # Copy our customization scripts
        cp -r ../rpi-image/* stage-rpi-player/
        
        # Make scripts executable
        chmod +x stage-rpi-player/00-rpi-player-config
        chmod +x stage-rpi-player/01-ffmpeg-build
        chmod +x stage-rpi-player/02-network-config
        chmod +x stage-rpi-player/03-splash-config
        chmod +x stage-rpi-player/files/*.sh
        
        # Create stage-list
        cat > stage-list << EOF
        stage0
        stage1
        stage2
        stage3
        stage4
        stage5
        stage-rpi-player
        EOF
        
        # Export stage list
        export STAGE_LIST="stage0 stage1 stage2 stage3 stage4 stage5 stage-rpi-player"
        
    - name: Build Raspberry Pi OS image
      run: |
        cd pi-gen
        sudo ./build.sh
        
    - name: Optimize image for RPI3
      run: |
        cd pi-gen/deploy
        
        # Find the built image
        IMAGE_FILE=$(ls rpi-player*.img 2>/dev/null | head -1)
        
        if [ -n "$IMAGE_FILE" ]; then
          echo "Optimizing image for RPI3..."
          
          # Mount the boot partition
          sudo mkdir -p /mnt/boot
          sudo mount -o loop,offset=$((512*8192)) "$IMAGE_FILE" /mnt/boot || true
          
          # Add boot config optimizations
          if [ -d /mnt/boot ]; then
            # Backup original config
            sudo cp /mnt/boot/config.txt /mnt/boot/config.txt.backup || true
            
            # Copy our optimized config
            sudo cp ../stage-rpi-player/files/config.txt /mnt/boot/config.txt || true
            
            # Copy cmdline.txt optimizations
            if [ -f ../stage-rpi-player/files/cmdline.txt ]; then
              sudo cp ../stage-rpi-player/files/cmdline.txt /mnt/boot/cmdline.txt || true
            fi
            
            sudo umount /mnt/boot || true
          fi
          
          # Compress the image
          gzip -c "$IMAGE_FILE" > "${IMAGE_FILE}.gz"
          
          # Generate checksum
          sha256sum "$IMAGE_FILE" > "${IMAGE_FILE}.sha256"
          sha256sum "${IMAGE_FILE}.gz" > "${IMAGE_FILE}.gz.sha256"
        else
          echo "No image file found in deploy directory"
          ls -la pi-gen/deploy/
        fi
        
    - name: Upload image artifacts
      uses: actions/upload-artifact@v4
      with:
        name: rpi-player-image
        path: |
          pi-gen/deploy/rpi-player*.img
          pi-gen/deploy/rpi-player*.img.gz
          pi-gen/deploy/rpi-player*.sha256
        retention-days: 30
        if-no-files-found: warn
        
    - name: Create Release
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: softprops/action-gh-release@v2
      with:
        files: |
          pi-gen/deploy/rpi-player*.img.gz
          pi-gen/deploy/rpi-player*.sha256
        name: RPI Player Image ${{ github.run_number }}
        tag: v${{ github.run_number }}
        draft: false
        prerelease: false
        body: |
          V-Player Enterprise Raspberry Pi Image with:
          - Professional Broadcasting Interface (AWS Elemental MediaLive style)
          - Complete Network Configuration (WiFi, Ethernet, Hotspot)
          - Cloudflare Zero Trust Integration for secure remote access
          - Hardware-accelerated video decoding
          - Web-based GUI interface with enterprise features
          - Broadcast video output options (HDMI, Composite, DSI, DPI)
          - Real-time network monitoring and metrics
          - Channel management and streaming controls
          - Auto-start service configuration
          - Professional splash screen and branding
          
          ## Installation:
          1. Download the `.img.gz` file
          2. Extract using: `gunzip rpi-player-*.img.gz`
          3. Flash to SD card using Raspberry Pi Imager
          4. Boot your Raspberry Pi (3, 4, or 5)
          5. Access web interface at: `http://rpi-player.local:5005`
          
          ## Default Settings:
          - SSH: Enabled (user: pi, password: raspberry)
          - Web Interface: http://localhost:5005
          - Service: Automatically starts on boot
          - Network: DHCP enabled, WiFi hotspot available
          
          ## Enterprise Features:
          - Professional broadcasting dashboard
          - Network configuration and monitoring
          - Cloudflare Zero Trust remote access
          - Video output management
          - Channel streaming controls
          - Real-time metrics and monitoring
          
          ## Network Configuration:
          - WiFi Client: Connect via web interface
          - WiFi Hotspot: SSID "V-Player-Hotspot", password "vplayer123"
          - Ethernet: DHCP enabled, static IP configuration available
          - Cloudflare: Zero Trust setup via web interface
          
          ## Troubleshooting:
          - Check logs: `sudo journalctl -u vplayer -f`
          - Service status: `sudo systemctl status vplayer`
          - Network tools: Available in web interface
          - Video output: Configurable via web interface
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
