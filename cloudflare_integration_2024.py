#!/usr/bin/env python3
"""
V-Player Cloudflare Zero Trust Integration (2024 Latest)
Dashboard-First Approach - Official Cloudflare Method

This module implements the latest 2024 Cloudflare Zero Trust integration
using the dashboard-first approach recommended by Cloudflare.
"""

import subprocess
import os
import json
import requests
from typing import Dict, Optional, List
from pathlib import Path

class CloudflareIntegration2024:
    """Cloudflare Zero Trust integration (2024 Dashboard-First Approach)"""
    
    def __init__(self):
        self.tunnel_name = 'vplayer-enterprise'
        self.service_name = 'cloudflared'
        self.config_dir = Path.home() / '.cloudflared'
        
    def check_cloudflared_installed(self) -> bool:
        """Check if cloudflared is installed"""
        try:
            result = subprocess.run(['cloudflared', '--version'], 
                                  capture_output=True, text=True)
            return result.returncode == 0
        except FileNotFoundError:
            return False
    
    def install_cloudflared_dashboard_method(self) -> Dict:
        """
        Install cloudflared using the dashboard-first method
        This returns the command that would be generated by Cloudflare dashboard
        """
        try:
            # Step 1: Download cloudflared (ARM64 for Raspberry Pi)
            download_url = "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-arm64.deb"
            
            download_cmd = [
                'curl', '-L', '--output', '/tmp/cloudflared.deb', download_url
            ]
            subprocess.run(download_cmd, check=True)
            
            # Step 2: Install package
            install_cmd = ['sudo', 'dpkg', '-i', '/tmp/cloudflared.deb']
            subprocess.run(install_cmd, check=True)
            
            # Step 3: Install as service (new 2024 method)
            service_cmd = ['sudo', 'cloudflared', 'service', 'install']
            subprocess.run(service_cmd, check=True)
            
            # Clean up
            os.remove('/tmp/cloudflared.deb')
            
            return {
                'success': True,
                'message': 'cloudflared installed successfully using dashboard method',
                'next_step': 'Run tunnel setup from Cloudflare dashboard'
            }
            
        except subprocess.CalledProcessError as e:
            return {
                'success': False,
                'error': f'Installation failed: {e}'
            }
    
    def generate_dashboard_instructions(self, hostname: str, local_port: int = 5004) -> Dict:
        """
        Generate instructions for dashboard-first setup
        This matches exactly what Cloudflare dashboard would show
        """
        return {
            'dashboard_steps': [
                {
                    'step': 1,
                    'title': 'Create Tunnel in Dashboard',
                    'instructions': [
                        'Go to https://one.dash.cloudflare.com',
                        'Navigate to Networks â†’ Connectors â†’ Cloudflare Tunnels',
                        'Click "Create a tunnel"',
                        'Select "Cloudflared" as connector type',
                        f'Enter tunnel name: "{self.tunnel_name}"',
                        'Click "Save tunnel"'
                    ]
                },
                {
                    'step': 2,
                    'title': 'Install cloudflared',
                    'instructions': [
                        'Choose "Linux (ARM64)" as environment',
                        'Copy the generated command',
                        'Run the command on your Raspberry Pi',
                        'Wait for connector to appear in dashboard',
                        'Click "Next"'
                    ]
                },
                {
                    'step': 3,
                    'title': 'Configure Public Hostname',
                    'instructions': [
                        'Go to "Public hostname" tab',
                        f'Enter subdomain: "vplayer"',
                        'Select your domain from dropdown',
                        'Service Type: "HTTP"',
                        f'URL: "http://localhost:{local_port}"',
                        'Click "Save hostname"'
                    ]
                },
                {
                    'step': 4,
                    'title': 'Configure Zero Trust Access',
                    'instructions': [
                        'Go to "Access" â†’ "Applications"',
                        'Click "Add an application" â†’ "Self-hosted"',
                        'Application name: "V-Player Enterprise"',
                        f'Destination URL: "https://{hostname}"',
                        'Session duration: "24h"',
                        'Click "Next"'
                    ]
                },
                {
                    'step': 5,
                    'title': 'Set Up Authentication',
                    'instructions': [
                        'Go to "Access" â†’ "Authentication"',
                        'Add login method (One-time PIN recommended)',
                        'Configure email delivery settings',
                        'Test authentication flow'
                    ]
                },
                {
                    'step': 6,
                    'title': 'Create Access Policy',
                    'instructions': [
                        'Go to "Access" â†’ "Policies"',
                        'Click "Add policy"',
                        'Policy name: "V-Player Access"',
                        'Action: "Allow"',
                        'Include: Email â†’ your-email@example.com',
                        'Application: "V-Player Enterprise"',
                        'Click "Save"'
                    ]
                }
            ],
            'access_url': f'https://{hostname}',
            'tunnel_name': self.tunnel_name,
            'local_service': f'http://localhost:{local_port}'
        }
    
    def get_tunnel_status_service_method(self) -> Dict:
        """Get tunnel status using the service method (2024 approach)"""
        try:
            # Check if service is installed
            result = subprocess.run(['sudo', 'systemctl', 'is-enabled', 'cloudflared'], 
                                  capture_output=True, text=True)
            service_enabled = result.stdout.strip() == 'enabled'
            
            # Check if service is running
            result = subprocess.run(['sudo', 'systemctl', 'is-active', 'cloudflared'], 
                                  capture_output=True, text=True)
            service_active = result.stdout.strip() == 'active'
            
            # Get service status details
            result = subprocess.run(['sudo', 'systemctl', 'status', 'cloudflared'], 
                                  capture_output=True, text=True)
            
            return {
                'installed': self.check_cloudflared_installed(),
                'service_enabled': service_enabled,
                'service_active': service_active,
                'status': 'active' if service_active else 'inactive',
                'details': result.stdout
            }
            
        except Exception as e:
            return {
                'installed': False,
                'service_enabled': False,
                'service_active': False,
                'status': 'error',
                'error': str(e)
            }
    
    def start_tunnel_service(self) -> Dict:
        """Start tunnel using service method"""
        try:
            subprocess.run(['sudo', 'systemctl', 'start', 'cloudflared'], check=True)
            return {
                'success': True,
                'message': 'Cloudflare tunnel service started'
            }
        except subprocess.CalledProcessError as e:
            return {
                'success': False,
                'error': f'Failed to start service: {e}'
            }
    
    def stop_tunnel_service(self) -> Dict:
        """Stop tunnel using service method"""
        try:
            subprocess.run(['sudo', 'systemctl', 'stop', 'cloudflared'], check=True)
            return {
                'success': True,
                'message': 'Cloudflare tunnel service stopped'
            }
        except subprocess.CalledProcessError as e:
            return {
                'success': False,
                'error': f'Failed to stop service: {e}'
            }
    
    def test_tunnel_connection(self, hostname: str) -> Dict:
        """Test tunnel connection"""
        try:
            import requests
            
            # Test connection with timeout
            response = requests.get(f'https://{hostname}', timeout=10)
            
            return {
                'accessible': True,
                'status_code': response.status_code,
                'response_time': response.elapsed.total_seconds(),
                'message': 'Tunnel is accessible'
            }
        except requests.exceptions.RequestException as e:
            return {
                'accessible': False,
                'error': str(e),
                'message': 'Tunnel not accessible'
            }
    
    def generate_setup_script_2024(self, hostname: str, local_port: int = 5004) -> str:
        """Generate setup script for 2024 dashboard-first approach"""
        script = f"""#!/bin/bash
# V-Player Cloudflare Zero Trust Setup Script (2024 Dashboard-First Method)

set -e

echo "ğŸš€ V-Player Cloudflare Zero Trust Setup (2024 Method)"
echo "ğŸ“‹ This script prepares your Raspberry Pi for dashboard-first setup"
echo ""

# Check if running as root
if [ "$EUID" -eq 0 ]; then
    echo "âŒ Please run this script as a regular user (not root)"
    exit 1
fi

# Update system
echo "ğŸ“¦ Updating system packages..."
sudo apt update && sudo apt upgrade -y

# Install curl if not present
echo "ğŸ“¦ Installing curl..."
sudo apt install -y curl

# Download and install cloudflared (ARM64 for Raspberry Pi)
echo "ğŸ“¦ Installing cloudflared for ARM64..."
curl -L --output /tmp/cloudflared.deb \\
    https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-arm64.deb

sudo dpkg -i /tmp/cloudflared.deb
rm /tmp/cloudflared.deb

# Install cloudflared as service (2024 method)
echo "ğŸ”§ Installing cloudflared as system service..."
sudo cloudflared service install

echo "âœ… cloudflared installation complete!"
echo ""
echo "ğŸŒ Next Steps (Dashboard Configuration):"
echo "1. Go to https://one.dash.cloudflare.com"
echo "2. Navigate to Networks â†’ Connectors â†’ Cloudflare Tunnels"
echo "3. Click 'Create a tunnel'"
echo "4. Select 'Cloudflared' connector type"
echo "5. Enter tunnel name: '{self.tunnel_name}'"
echo "6. Save tunnel and copy the generated command"
echo "7. Run the generated command on this Raspberry Pi"
echo ""
echo "ğŸ“± Public Hostname Configuration:"
echo "- Subdomain: vplayer"
echo "- Domain: yourdomain.com (or pages.dev)"
echo "- Service Type: HTTP"
echo "- URL: http://localhost:{local_port}"
echo ""
echo "ğŸ”’ Zero Trust Configuration:"
echo "- Create Access Application: 'V-Player Enterprise'"
echo "- Destination URL: https://{hostname}"
echo "- Set up authentication (One-time PIN recommended)"
echo "- Create access policy for your email"
echo ""
echo "ğŸŒ Your V-Player will be accessible at: https://{hostname}"
echo ""
echo "ğŸ¯ After dashboard setup, run: sudo systemctl start cloudflared"
"""

        return script
    
    def get_cloudflare_version(self) -> Dict:
        """Get cloudflared version information"""
        try:
            result = subprocess.run(['cloudflared', '--version'], 
                                  capture_output=True, text=True)
            return {
                'installed': True,
                'version': result.stdout.strip()
            }
        except FileNotFoundError:
            return {
                'installed': False,
                'version': None
            }

# Example usage
if __name__ == "__main__":
    cf = CloudflareIntegration2024()
    
    # Generate instructions
    hostname = "vplayer.yourdomain.com"
    instructions = cf.generate_dashboard_instructions(hostname)
    
    print("ğŸŒ Cloudflare Zero Trust Setup Instructions (2024)")
    print("=" * 50)
    
    for step in instructions['dashboard_steps']:
        print(f"\nğŸ“ Step {step['step']}: {step['title']}")
        print("-" * 30)
        for instruction in step['instructions']:
            print(f"  â€¢ {instruction}")
    
    print(f"\nğŸŒ Final Access URL: {instructions['access_url']}")
    print(f"ğŸ”§ Tunnel Name: {instructions['tunnel_name']}")
